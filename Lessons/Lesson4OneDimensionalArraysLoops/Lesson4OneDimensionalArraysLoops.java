package org.example;

import java.util.Arrays;

public class Lesson4OneDimensionalArraysLoops {
    public static void main(String[] args) {

//Перевод логики на картинке https://live.staticflickr.com/364/20297660150_aa0a84d51c_b.jpg в код:

        boolean itMoves = true;
        boolean shouldItMove = false;

        if (itMoves == shouldItMove) {
            System.out.println("No problem");
        } else if (itMoves) {
            System.out.println("Use duct tape");
        } else {
            System.out.println("Use WD-40");
        }

//Long way
        if (itMoves) {
            if (shouldItMove) {
                System.out.println("No problem");
            } else {
                System.out.println("Use duct tape");
            }
        } else {
            if (shouldItMove) {
                System.out.println("Use WD-40");
            } else {
                System.out.println("No problem");
            }
        }



//Переменные у нас бывают не только числовые, строковые, булевые.
//Бывают МАССИВЫ.
//
//Массивы это особый вид переменных, когда одна переменная моделирует/представляет из себя целый набор из однотипных
//значений.
//
//В динамических языках это не так важно, там в массив можно положить разные типы данных. А т.к. Java это строго
//типизированный язык, то такие вольности в ней не позволительны. Когда мы объявляем массив, то сразу объявляем тип всех
//элементов.
//
//Массив это переменная которая указывает на ряд элементов. В массиве лежат однотипные значения, где каждое индивидуальное
//значение имеет индекс. Индексы начинаются с 0. То есть, есть нулевой элемент, самый первый по порядку. Есть 1-ый элемент
//который второй по порядку и т.д.
//К любому элементу массива можно получить доступ по индексу.
//В Java мы можем читать этот элемент и писать этот элемент. Желательно избегать возможности динамического добавления и
//удаления данных из массива. Например, если мы убрали элемент под индексом "4", то произойдёт смещение, элемент под
//индексом "5" сместится на "4" и т.д.

//например возьмем пример с классным журналом и оценками у одного из учеников.

       int[] scoreMarks = new int[] {5, 5, 5, 5, 4, 3, 2, 1, 3, 3, 4, 5, 5, 5};
            System.out.println(scoreMarks[5]); //Здесь мы обращаемся, как и говорили ранее, к массиву - по индексу.
        scoreMarks[6] = 4; //здесь мы изменяем наши данные в массиве
        scoreMarks[7] = 4;
//            System.out.println(scoreMarks); - если мы попробуем распечатать массив в таком виде, то получим непонятный
// для пользователя набор символов, т.к. массивы на самом деле это некая помесь примитивных типов и объектов, поэтому в
// консоль выведется объектная подпись массива.
// Стандартная библиотека Java даёт нам метод, который позволяет печатать значения массива - Arrays.toString(ArrayName)
// System.out.println(Arrays.toString(scoreMarks)); //где объект - Arrays, у него есть метод - toString,
// который берёт массив и выводит понятную нам строку


//Вообще большие массивы однотипных данных это то, ради чего были придуманы компьютеры.


// Самое простое, что мы можем сделать это не пользоваться Arrays.toString и напечатать каждое значение. Для этого мы
// используем распечатывание каждого значения через цикл


        int[] scoreMarks = new int[]{5, 3, 4, 2};
        for (int i = 0; i < scoreMarks.length; i = i + 1) {
            int score = scoreMarks[i];
            if (score < 4) {
                scoreMarks[i] = score + 1;
            }
        }
        System.out.println(Arrays.toString(scoreMarks));


//название_массива.length - это свойство массива определяющее длину массива
//в примере выше мы рассматриваем такой случай, что мы задаём переменную i равную нулю и задаём условие на цикл, что
//цикл будет выполняться, пока i меньше длины массива, в данном случае количества индексов и после окончания каждого
//цикла к переменной i добавляется единица.
//Тут же мы просматриваем пример когда мы перебираем массив и внутри него мы увеличиваем нашу оценку на единицу если
//оценка менее 4.

        int[] scoreMarks = new int[] {5, 3, 4, 2};
        int sum = 0;
        for (int i = 0; i < scoreMarks.length; i = i + 1) {
                sum = sum + scoreMarks[i];
            }
            System.out.println(sum * 1.0 / scoreMarks.length);

//Выше мы рассмотрели расчёт средней оценки. После того как мы объявили массив, мы объявили переменную аккумулятор,
//куда будем каждый цикл добавлять оценки из массива и по этому делим сумму на количество оценок. Не забываем про Double.

        int[] scoreMarks = new int[]{5, 3, 4, 2};

        int min = Integer.MAX_VALUE;
        for (int i = 0; i < scoreMarks.length; i = i + 1) {
            int elem = scoreMarks[i];
            if (elem < min) {
                min = elem;
            }
        }
        System.out.println(min);

//Выше мы рассмотрели пример, где мы находим минимальное число элемент внутри массива. Чтобы выполнить это задание,
//мы присвоили переменной min заведомо очень большое значение Integer.MAX_VALUE (2147483647) и сравнили со всем
//массивом. Самое маленькое число из массива записалось в переменную min. То же самое мы делаем при поиске самого
//большого числа, присвоили изначально переменной min заведомо очень малое значение Integer.MIN_VALUE (-2147483648).
//Ссылка на объяснение подобного примера:
// https://www.tutorialspoint.com/integer-max-value-and-integer-min-value-in-java-with-examples

        int[] arr = new int[] {5, 3, 4, 2};

        int[] results = new int[arr.length];

        for (int i = 0; i < arr.length; i = i + 1) {
            int elem = arr[i];
            results[i] = elem * elem;
        }
        System.out.println(Arrays.toString(results));

// Здесь мы из изначального массива берём каждое значение и возводим в квадрат. Для этого берем и создаём пустой массив,
// но говорим ему, что количество его элементов внутри будет соответствовать длине первого массива и внутри цикла

// Ниже мы смотрим на следующий тип цикла - while и на примере показано, что в круглых скобках после слова while у нас
// есть какое-то условие, в данном примере если наше значение true, то цикл будет выполняться. Если внутри цикл данные
// для условия не будут изменены, то цикл окажется бесконечным.

        boolean cond = true;

        while (cond) {
            System.out.println("Hi! I'm here!");
            cond = false;
        }

// Ниже представлен еще один пример по входу в цикл. Мы хотим 5 раз напечатать слово "I'm here!". Для этого мы создали
// переменную counter, присвоили ей значение 0, внутри цикла добавляем к значению counter по единице за каждый проход
// по циклу. Когда мы пишем ++ напротив названия переменной это означает, что мы её инкрементируем.
// Инкреме́нт, инкрементирование (от англ. increment «увеличение») — операция во многих языках программирования,
// увеличивающая значение переменной. И наоборот декремент - запись с минусами, которая уменьшает значение переменной.
// Такой вид цикла хорош для моментов, когда мы не знаем, есть ли у нас данные для обработки, нужно ли первый раз
// входить в цикл. Такой вид цикла хорош, когда мы читаем поток данных из внешнего устройства, или из файла, или когда
// юзер вводит строку и мы прогоняем введенные данные по циклу. Точно так же для приведенного примера можно
// использовать и цикл for.

        int counter = 0;

        while (counter < 5) {
            System.out.println("I'm here");
            counter++;
        }

// Ниже представлен еще один цикл. В нём мы что-то делаем пока выполняется какое-то условие, в принципе, как и ранее.
// Так же новое внутри примера - counter += 1 это то же самое, что и counter = counter + 1.
// Часть do в нём выполнится обязательно в первый раз, потому что она стоит перед тем, как проверяется условие
// находящееся внутри части while.

        int counter = 0;

        do {
            System.out.println("I'm here!");
            counter += 1;
        } while (counter < 5);

// Ниже напишем программу для угадывания чисел. Устанавливаем нижнюю и верхнюю границу и делим пополам до тех пор, пока
// мы не найдём наше загаданное число в переменной MyNumber. Последним выведенным результатом будет наше загаданное
// число.

         int max = 100;
         int min = 0;
         int MyNumber = 15;

         int guess;

         do {
             guess = (max + min) / 2;
             System.out.print("I'm guessing ");
             System.out.println(guess);
             if (guess < MyNumber) {
                 min = guess;
             } else {
                 max = guess;
             }
         } while (guess != MyNumber);

    }
}